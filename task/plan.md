# План реализации KeySloth - Ruby Gem для управления зашифрованными секретами

## 1. Подготовка проекта

### 1.1 Структура gem'а
- [x] Создать основную структуру ruby gem'а
- [x] Настроить gemspec файл с описанием и зависимостями
- [x] Создать базовую структуру директорий (lib/, bin/, spec/, etc.)
- [x] Настроить Gemfile с необходимыми зависимостями

### 1.2 Инфраструктура
- [x] Настроить RSpec для тестирования
- [x] Настроить RuboCop для линтинга кода
- [x] Создать базовый Rakefile
- [ ] Настроить CI/CD (GitHub Actions)

## 2. Основная функциональность

### 2.1 Криптографический модуль
- [x] Реализовать модуль шифрования/дешифрования файлов
- [x] Выбрать алгоритм шифрования (AES-256-GCM)
- [x] Реализовать генерацию ключей из паролей (PBKDF2)
- [x] Добавить обработку различных типов файлов (.cer, .p12, .mobileprovisioning, .json)

### 2.2 Работа с Git репозиториями
- [x] Реализовать клонирование удаленного репозитория (через системные команды)
- [x] Реализовать переключение на нужную ветку
- [x] Реализовать получение файлов из репозитория
- [x] Реализовать коммит и push изменений обратно в репозиторий
- [x] Добавить очистку временных файлов после работы

### 2.3 Управление файловой системой
- [x] Реализовать создание локальной директории для секретов
- [x] Реализовать извлечение зашифрованных файлов в локальную директорию
- [x] Реализовать упаковку измененных файлов для отправки в репозиторий
- [x] Добавить валидацию путей и проверку прав доступа

## 3. Интерфейс командной строки

### 3.1 Команда получения секретов
- [x] Реализовать команду `pull` для получения и дешифровки секретов
- [x] Параметры: URL репозитория, ветка, пароль, путь к локальной директории
- [x] Добавить валидацию входных параметров
- [x] Реализовать подробное логирование процесса
- [x] Добавить обработку ошибок (неверный пароль, недоступный репозиторий, etc.)

### 3.2 Команда отправки секретов
- [x] Реализовать команду `push` для шифровки и отправки секретов
- [x] Те же параметры что и для pull
- [x] Добавить проверку изменений перед отправкой
- [x] Реализовать создание коммита с описанием изменений
- [x] Добавить подтверждение действия перед отправкой

### 3.3 Help команда
- [x] Реализовать команду `help` с описанием всех команд
- [x] Добавить примеры использования
- [x] Добавить описание параметров и опций
- [x] Создать man-страницу или подробную документацию

### 3.4 Дополнительные команды
- [x] Реализовать команду `init` для первичной настройки
- [x] Добавить команду `status` для проверки состояния локальных секретов
- [x] Реализовать команду `validate` для проверки целостности файлов
- [x] Добавить команду `restore` для восстановления из backup'а
- [x] Добавить команду `version` для отображения версии

## 4. Безопасность и обработка ошибок

### 4.1 Безопасность
- [x] Добавить проверку целостности зашифрованных файлов

### 4.2 Обработка ошибок
- [x] Добавить логирование ошибок и отладочной информации

## 5. Тестирование

### 5.1 Unit тесты
- [x] Написать тесты для криптографического модуля
- [x] Написать тесты для работы с файловой системой
- [x] Написать тесты для Git операций
- [x] Написать тесты для CLI интерфейса

## 6. Документация и комментарии

### 6.1 Код документация
- [x] Добавить подробные комментарии ко всем публичным методам
- [x] Создать YARD документацию
- [x] Добавить примеры использования в комментариях
- [x] Документировать все исключения и edge cases

### 6.2 Пользовательская документация
- [x] Создать README.md с инструкциями по установке и использованию
- [x] Написать CHANGELOG.md
- [x] Создать примеры использования в Makefile
- [x] Добавить troubleshooting guide

## 7. Публикация и развертывание

### 7.1 Подготовка к публикации
- [x] Финальная проверка всех тестов
- [x] Код-ревью и рефакторинг
- [x] Проверка безопасности и соответствия best practices
- [x] Финализация версии и тегирование

### 7.2 Публикация
- [ ] Публикация gem'а в RubyGems.org
- [ ] Создание GitHub release с описанием изменений
- [ ] Обновление документации на публичных ресурсах
- [ ] Создание примеров интеграции с популярными CI/CD системами

## 8. Поддержка и развитие

### 8.1 Мониторинг
- [ ] Настроить мониторинг использования gem'а
- [ ] Создать систему сбора обратной связи
- [ ] Настроить автоматические уведомления о проблемах

### 8.2 Развитие
- [ ] Планирование будущих фич (GUI интерфейс, интеграции)
- [ ] Поддержка обратной совместимости
- [ ] Регулярные обновления зависимостей
- [ ] Поддержка сообщества пользователей





## Вопросы для уточнения

### 9.1 Технические детали
- [x] Какой алгоритм шифрования использовать? (AES-256-GCM, ChaCha20-Poly1305, другой?)
  **Ответ:** AES-256-GCM - наиболее подходящий выбор, так как обеспечивает защиту целостности данных и аутентификацию, широко поддерживается, имеет хорошую производительность и является стандартом индустрии.

- [x] В каком формате хранить зашифрованные файлы в репозитории? (один архив или отдельные файлы?)
  **Ответ:** Отдельные зашифрованные файлы с сохранением исходных имен + расширение .enc. Это обеспечивает гранулярность изменений в Git, позволяет отслеживать изменения конкретных файлов и упрощает парциальное обновление секретов.

- [x] Как именно будет называться gem? (KeySloth или другое имя?)
  **Ответ:** KeySloth - подходящее название, отражает суть инструмента (ключи + медленная и осторожная работа с секретами). Альтернатива: SecretSloth.

### 9.2 Git и аутентификация
- [x] Поддерживать только HTTPS или также SSH ключи для доступа к репозиторию?
  **Ответ:** Только SSH ключи. Это обеспечивает более высокий уровень безопасности и исключает необходимость передачи паролей/токенов. В CI/CD системах также можно настроить SSH ключи через deploy keys или service accounts.

- [x] Как передавать учетные данные Git? (параметры команды, переменные окружения, git credential helper?)
  **Ответ:** Использование SSH ключей. Для локальной работы - стандартные SSH ключи из ~/.ssh/. Для CI/CD - настройка SSH ключей через переменные окружения (SSH_PRIVATE_KEY) или секреты системы CI/CD. Автоматическое добавление хостов в known_hosts при необходимости.

### 9.3 CLI интерфейс
- [x] Нужен ли namespace для команд? (например `keysloth pull` vs отдельные исполняемые файлы?)
  **Ответ:** Да, использовать namespace `keysloth <command>`. Это современный подход, обеспечивает чистоту пространства имен системы и упрощает добавление новых команд. Основные команды: `keysloth pull`, `keysloth push`, `keysloth help`.

- [x] Нужна ли поддержка конфигурационных файлов для хранения URL репозитория и других параметров?
  **Ответ:** Да, опциональная поддержка `.keyslothrc` (YAML формат) для хранения URL репозитория, ветки по умолчанию, путей. Параметры командной строки должны иметь приоритет над конфигом для гибкости в CI/CD.

### 9.4 Обработка конфликтов
- [x] Как обрабатывать ситуацию, когда несколько разработчиков одновременно изменяют секреты?
  **Ответ:** Использовать стратегию "fail-fast": перед push выполнять pull и проверять изменения. При обнаружении конфликтов - прекращать операцию с подробным сообщением об ошибке и рекомендациями по разрешению. Добавить команду `keysloth status` для проверки состояния.

- [x] Как разрешать конфликты при слиянии изменений в Git?
  **Ответ:** Не автоматически. Инструмент должен обнаруживать конфликты и требовать ручного разрешения администратором проекта. Предоставлять детальную информацию о конфликтующих файлах и временных метках изменений.

### 9.5 Дополнительные требования
- [x] Какие версии Ruby должны поддерживаться? (2.7+, 3.0+ и т.д.)
  **Ответ:** Ruby 2.7+ для совместимости с современными CI/CD системами и не слишком устаревшими проектами. Активно тестировать на Ruby 2.7, 3.0, 3.1, 3.2. Указать minimum_ruby_version = "2.7.0" в gemspec.

- [x] Нужны ли подробные логи работы? В какой формат? (stdout, файлы?)
  **Ответ:** Да, многоуровневое логирование. По умолчанию INFO в stdout. Параметр `--verbose` для DEBUG уровня. Параметр `--quiet` для только ERROR. Логи в простом текстовом формате с timestamp для удобства отладки в CI/CD.

- [x] Нужна ли возможность создания резервных копий перед изменениями?
  **Ответ:** Да, автоматическое создание backup'ов локальной директории с секретами перед выполнением pull операций. Хранить последние 3 копии с временными метками. Команда `keysloth restore` для восстановления из backup'а. 